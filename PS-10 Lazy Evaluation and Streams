;counter

(define count 0)

 (define (id x)
     (set! count (+ count 1))
     x)
     
 (define (square x)
      (* x x))
     
;#|
;> count
;0
;> (id 2)
;2
;> count
;1
;> (id 5)
;5
;> count
;2
;>(square (id 10))
;100
;>count
;4   ;(doesn't use memoization) | (if it is use, count would be 3) 
;|#

;-----Interleaving streams ----;
;#|
;Write a procedure, (interleave s1 s2), that takes two streams and interleaves them. So, if
;   ones = (1 1 1 ...)
;   twos = (2 2 2 ...)
;   (interleave ones twos) = (1 2 1 2 1 2 ....)
;|#

(define (interleave lst1 lst2)
   (if (null? lst1) '()
       (cons-stream (stream-car lst1) (interleave lst2 (stream-cdr lst1)))))
       
       
;-----Mapping over a stream  ----;       
;#|
;Write a procedure, analogous to map, that takes a stream and a procedure and 
;returns the stream of values resulting from applying the procedure to each element 
;of the stream. You don't have to worry about dealing with the null stream. Assume 
;that cons-stream, stream-car and stream-cdr provide the data abstraction for a stream.
;We will also use the first few values of the stream as a way of testing equality in our test cases.       
;|#
 
;it is like eval-sequence         (EVAL-SEQUENCE IS SO USEFULL PROCEDURE) 
(define (map-stream proc stream)
  (cons-stream (proc (stream-car stream)) (map-stream proc (stream-cdr stream)))) 
  
 
;-----Filtering a stream ----;

;#|
;Write a procedure, analogous to filter, that takes a stream and a predicate and returns 
;the stream of values for which the predicate returns #t. You don't have to worry about 
;dealing with the null stream. Assume that cons-stream, stream-car and stream-cdr provide 
;the data abstraction for a stream.
;|#

(define (filter-stream proc stream)
  (if (proc (stream-car stream))
      (cons-stream (stream-car stream) (filter-stream proc (stream-cdr stream)))
      (filter-stream proc (stream-cdr stream))))
      
;-----Fibonacci numbers ----;

;#|
;Write a procedure, (fibs), that returns a stream of Fibonacci numbers. The Fibonacci series goes
;   (1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 ...)
;It starts with two 1's, then each successive value is the sum of the previous two. You may use
;the function (map2-stream p s1 s2), which maps a procedure of two arguments over two streams. 
;A particularly useful application of it is:
;    (map2-stream + ones twos) => (3 3 3 3 3 ....)
;
;Hint 0: Think about how many initial values you need to cons onto the front of the stream before 
;you can create a recursive data structure.
;|#

(define fibs
  (lambda ()
    (define fibstream
     
        (cons-stream 1 (cons-stream 1
                                    (map2-stream + fibstream
                                                 (stream-cdr fibstream)))))
    fibstream))
      
