;counter

(define count 0)

 (define (id x)
     (set! count (+ count 1))
     x)
     
 (define (square x)
      (* x x))
     
;#|
;> count
;0
;> (id 2)
;2
;> count
;1
;> (id 5)
;5
;> count
;2
;>(square (id 10))
;100
;>count
;4   ;(doesn't use memoization) | (if it is use, count would be 3) 
;|#

;-----Interleaving streams ----;
;#|
;Write a procedure, (interleave s1 s2), that takes two streams and interleaves them. So, if
;   ones = (1 1 1 ...)
;   twos = (2 2 2 ...)
;   (interleave ones twos) = (1 2 1 2 1 2 ....)
;|#

(define (interleave lst1 lst2)
   (if (null? lst1) '()
       (cons-stream (stream-car lst1) (interleave lst2 (stream-cdr lst1)))))
       
       
;-----Mapping over a stream  ----;       
;#|
;Write a procedure, analogous to map, that takes a stream and a procedure and 
;returns the stream of values resulting from applying the procedure to each element 
;of the stream. You don't have to worry about dealing with the null stream. Assume 
;that cons-stream, stream-car and stream-cdr provide the data abstraction for a stream.
;We will also use the first few values of the stream as a way of testing equality in our test cases.       
;|#
 
;it is like eval-sequence         (EVAL-SEQUENCE IS SO USEFULL PROCEDURE) 
(define (map-stream proc stream)
  (cons-stream (proc (stream-car stream)) (map-stream proc (stream-cdr stream)))) 
  
 
;-----Filtering a stream ----;

;#|
;Write a procedure, analogous to filter, that takes a stream and a predicate and returns 
;the stream of values for which the predicate returns #t. You don't have to worry about 
;dealing with the null stream. Assume that cons-stream, stream-car and stream-cdr provide 
;the data abstraction for a stream.
;|#

(define (filter-stream proc stream)
  (if (proc (stream-car stream))
      (cons-stream (stream-car stream) (filter-stream proc (stream-cdr stream)))
      (filter-stream proc (stream-cdr stream))))
